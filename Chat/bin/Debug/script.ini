
        function mainfileprogress(gfkey) {
            if (gfkey == '') return;
            var divs = getElementsByClassName(document, 'c_' + gfkey);
            var totwidth = 0;
            var totfile = divs.length;
            if (totfile ==0) return;

            var fper = 0;
            var par = getElementsByClassName(document, 'meter_' + gfkey)[0];
            var pendingcnt=0;

            for (i = 0; i < divs.length; i++) 
			{
                if (getElementsByClassName(divs[i],'meter-text').length > 0) {

                    fper = parseInt(getElementsByClassName(divs[i],'meter-text')[0].innerHTML.replace("%", ""));
                    if (fper == -1 || fper == -2) {
                        totfile = totfile - 1;
                    } else {
                        totwidth = totwidth + fper;
                        if (getElementsByClassName(divs[i],'sending')[0].style.display ==""){
                          pendingcnt = pendingcnt + 1;
                        }
                    }
                }
            }


            totwidth = Math.round(totwidth / totfile);
            if (isNaN(totwidth)) {
                totwidth = 0;
            }
            var meterex = document.getElementById ('meter-ex_' + gfkey);
            getElementsByClassName(meterex,'meter-value')[0].style.width = totwidth + '%';
            getElementsByClassName(meterex,'meter-text')[0].innerHTML = totwidth + '%';


            var groupmetercontainer = getElementsByClassName(par,'group-meter-container')[0];
            if ((totfile == 0 || totwidth == 100) && pendingcnt==0) {
                groupmetercontainer.style.display='none';
            } else {
                groupmetercontainer.style.display='inline';
            }
            updatemainstatus(gfkey);

        };
        function fileprogress(h, perc) {
            var par =document.getElementById (h);

            var meterex = document.getElementById ('meter-ex_' + h);
            var progress = getElementsByClassName(meterex,'meter-text')[0].innerHTML;
            if (progress == -1 || progress == -2) return;

            getElementsByClassName(meterex,'meter-value')[0].style.width = perc + '%';
            getElementsByClassName(meterex,'meter-text')[0].innerHTML = perc + '%';

            getElementsByClassName(par,'meter-container')[0].style.display='inline';
            //if (gfkey != '') {
            //    mainfileprogress(gfkey);
            //}
            //if (perc == 100) {
            //    getElementsByClassName(par,'status')[0].innerHTML='';
            //    getElementsByClassName(par,'sending')[0].style.display='none';
            //}
        }

function updatemainstatus(gfkey) {
            var completed = 0;
            var pending = 0;
            var inprogress = 0;
            var cancelled = 0;
            var timeout = 0;
            var divs = getElementsByClassName(document,'c_' + gfkey);

            for (i = 0; i < divs.length; i++) {
                if (getElementsByClassName(divs[i],'meter-text').length > 0) {
                    switch (parseInt(getElementsByClassName(divs[i],'meter-text')[0].innerHTML.replace("%", ""))) {
                        case -2:
                            timeout = timeout + 1;
                            break;
                        case -1:
                            cancelled = cancelled + 1;
                            break;
                        case 0:
                            pending = pending + 1;
                            break;
                        case 100:
                          if (getElementsByClassName(divs[i],'sending')[0].style.display ==""){
                            inprogress = inprogress + 1;
                          }
                          else {
                            completed = completed + 1;
                          }
                            break;
                        default:
                            inprogress = inprogress + 1;
                            break;
                    }
                }
            }

            var html = '';
            if (completed > 0) {
                html += completed + ' Completed; ';
            }
            if (cancelled > 0) {
              html += cancelled + ' Cancelled; ';
            }
            if (timeout > 0) {
                html += timeout + ' Timeout; ';
            }
            if (inprogress > 0) {
                html += inprogress + ' Inprogress; ';
            }
            if (pending > 0) {
                html += pending + ' Pending; ';
            }

            document.getElementById('lbl' + gfkey).innerHTML=html;
        }
        function autodownloadfile(hash) {
          var ahash = hash.split(",");
          for (var i = 0; i <ahash.length; i++) {
            var dv = document.getElementById(ahash[i]);
            if (dv) {
              var span = getElementsByClassName(dv, 'autodownloadfile')[0];
              if(span) {
                span.click();
              }
            }
          }
        }

        function acceptfile(h) {
            var par = document.getElementById(h);
            getElementsByClassName(par,'status')[0].innerHTML = 'Receiving';
            getElementsByClassName(par,'accept')[0].style.display = 'none';
        }
        function filestatus(h, status) {
            var par = document.getElementById(h);
            getElementsByClassName(par,'status')[0].innerHTML = status;
        }
        function openreceivedfile(h, url){
          var par = document.getElementById(h);
          if (getElementsByClassName(par,'status')[0].innerText.trim() == ""){
            window.external.OpenReceivedFile(url);
          }
        }
        function openordownloadfile(h, url, key, createdtime, filehash, filename, fromname, sessionid, messageid, fileid, parentkey){
          var par = document.getElementById(h);
          if (getElementsByClassName(par,'status')[0].innerText.trim() == ""){
            //window.external.OpenReceivedFile(url);
            window.external.OpenOrDownloadFile(url, key, createdtime, filehash, filename, fromname, sessionid, messageid, fileid, parentkey);
          }
        }
        function filereceived(h) {
            var par = document.getElementById(h);

            getElementsByClassName(par,'receiving')[0].style.display = 'none';
            getElementsByClassName(par,'status')[0].style.display = 'none';
            getElementsByClassName(par,'status')[0].innerHTML = "";
            getElementsByClassName(par,'received')[0].style.display = 'none';
            getElementsByClassName(par,'openfile')[0].style.display = 'inline';
            getElementsByClassName(par,'r_status')[0].innerHTML = "";
            setwidth(par);
        }
        function showsmallimage(h, filename, width, height, sameuser) {
            var par = document.getElementById(h);
            getElementsByClassName(par,'file_format')[0].style.display = 'none';
            getElementsByClassName(par,'small_file')[0].style.display = 'inline';
            var img = document.getElementById('s_'+h);
            img.src = filename;
            img.width = width;
            img.height = height;
            if(sameuser==1){
              getElementsByClassName(par,'r_file_block_size')[0].style.right = (parseInt(width) + 50) +'px';
            }
            hideopenfolder(par);
        }
        function showaudiofile(h, ahtml) {
            var par = document.getElementById(h);
            getElementsByClassName(par,'file_format')[0].style.display = 'none';
            getElementsByClassName(par,'audio_file')[0].style.display = 'inline';
            getElementsByClassName(par,'audio_file')[0].innerHTML = ahtml;
        }
        function receivershowaudiofile(h, ahtml) {
            showaudiofile(h, ahtml)
            hideopenfolder(par);
        }
        function showfilename(that) {
            var sendingobj = getElementsByClassName(that, 'sending')[0];
            if (sendingobj) {
                if (sendingobj.style.display == 'inline' || sendingobj.style.display == '') return;
            }
            var smallfileobj = getElementsByClassName(that, 'small_file')[0];
            var audiofileobj = getElementsByClassName(that, 'audio_file')[0];

            if (smallfileobj) {
                if (smallfileobj.style.display != 'inline') return;
                if (smallfileobj.getAttribute("fnf") != null) return;
                getElementsByClassName(that,'filename')[0].style.display = 'inline';            
            }
            else if (audiofileobj) {
                if (audiofileobj.style.display != 'inline') return;
                getElementsByClassName(that,'filename')[0].style.display = 'inline';            
            }
        }
        function hidefilename(that) {
            var sendingobj = getElementsByClassName(that, 'sending')[0];
            if (sendingobj) {
                if (sendingobj.style.display == 'inline' || sendingobj.style.display == '') return;
            }
            
          if (getElementsByClassName(that, 'status').length> 0 && getElementsByClassName(that, 'status')[0].innerHTML != "") return; 
          
            var smallfileobj = getElementsByClassName(that, 'small_file')[0];
            var audiofileobj = getElementsByClassName(that, 'audio_file')[0];
            if (smallfileobj) {
                if (smallfileobj.style.display != 'inline') return;
                if (smallfileobj.getAttribute("fnf") != null) return;
                getElementsByClassName(that,'filename')[0].style.display = 'none';
            }else if (audiofileobj) {
                if (audiofileobj.style.display != 'inline') return;
                getElementsByClassName(that,'filename')[0].style.display = 'none';
            }
        }
        function showopenfolder(that) {
            var smallfileobj = getElementsByClassName(that, 'small_file')[0];
            var audiofileobj = getElementsByClassName(that, 'audio_file')[0];
            if (smallfileobj) {
                if (smallfileobj.style.display != 'inline') return;
                if (smallfileobj.getAttribute("fnf") != null) return;
                getElementsByClassName(that, 'filename')[0].style.display = 'inline';
                getElementsByClassName(that, 'openfile')[0].style.display = 'inline';
            }else if (audiofileobj) {
                if (audiofileobj.style.display != 'inline') return;
                getElementsByClassName(that, 'filename')[0].style.display = 'inline';
                getElementsByClassName(that, 'openfile')[0].style.display = 'inline';
            }
            if (that.parentNode) {
              if (that.parentNode.className == 'forward_message') {
                var dv = getElementsByClassName(that, 'r_file_block_size')[0];
                if (dv) {
                  if (dv.style.left == '') {
                    dv.style.left = (that.parentNode.offsetWidth + 10) + 'px';
                  }
                }
              }
            }
        }
        function hideopenfolder(that) {
            var smallfileobj = getElementsByClassName(that, 'small_file')[0];
            var audiofileobj = getElementsByClassName(that, 'audio_file')[0];
            if (smallfileobj) {
                if (smallfileobj.style.display != 'inline') return;
                if (smallfileobj.getAttribute("fnf") != null) return;
                getElementsByClassName(that, 'filename')[0].style.display = 'none';
                getElementsByClassName(that, 'openfile')[0].style.display = 'none';
            }else if (audiofileobj) {
                if (audiofileobj.style.display != 'inline') return;
                getElementsByClassName(that, 'filename')[0].style.display = 'none';
                getElementsByClassName(that, 'openfile')[0].style.display = 'none';
            }
        }
        function cancelreceivingfile(h) {
            var par = document.getElementById(h);
            getElementsByClassName(par,'cancelled')[0].style.display = 'inline';
            getElementsByClassName(par,'receiving')[0].style.display = 'none';
            //getElementsByClassName(par,'status')[0].style.display = 'none';
            getElementsByClassName(par,'status')[0].innerHTML = "";

            getElementsByClassName(par,'downloadfile')[0].style.display = 'inline';
        }
        function updatedownloadfilestatus(h, status) {
            var par = document.getElementById(h);
            if (par){
              var statusobj = getElementsByClassName(par,'status')[0];
              if(statusobj){
                statusobj.style.display = 'inline';
                statusobj.innerHTML = status;
              }
            }
        }
        function timeoutreceivingfile(h, status, autodownload) {
            var par = document.getElementById(h);
            getElementsByClassName(par,'cancelled')[0].style.display = 'inline';
            getElementsByClassName(par,'receiving')[0].style.display = 'none';
            //getElementsByClassName(par,'status')[0].style.display = 'none';
            getElementsByClassName(par,'status')[0].innerHTML = "";
            getElementsByClassName(par,'rc_status')[0].innerHTML = status;

            getElementsByClassName(par,'downloadfile')[0].style.display = 'inline';
            if (autodownload ==1){
                getElementsByClassName(par,'downloadfilespan')[0].click();
            }
        }
        function setwidth(par){
            var dv= getElementsByClassName(par,'single_inline_block')[0];
            if(dv){
              if(dv.getAttribute("w")){
                dv.style.width = dv.getAttribute("w") +'px';
                if (dv.className.indexOf('r_file_block_size') > -1){
                    dv.style.height = '40px';
                }
              }
              if (dv.className.indexOf('r_file_block_size') > -1){
                  dv.style.marginLeft ='20px';
              }
              if(dv.getAttribute("r")){
                dv.style.right = dv.getAttribute("r") +'px';
              }
            }
        }
        function sentfile(h) {
            var par = document.getElementById(h);

            getElementsByClassName(par,'status')[0].innerHTML = '';
            getElementsByClassName(par,'sending')[0].style.display = 'none';
            getElementsByClassName(par,'filesize')[0].style.display = 'none';
            getElementsByClassName(par,'meter-text')[0].innerHTML = '100%';
            var simgdiv = getElementsByClassName(par, 'small_file')[0];
            if(simgdiv){
              getElementsByClassName(par,'filename')[0].style.display = 'none';
            }
            setwidth(par);
            getElementsByClassName(par,'meter-value')[0].innerHTML = '';
            getElementsByClassName(par,'retryfilespan')[0].innerHTML = '';
            getElementsByClassName(par,'filesize')[0].innerHTML = '';
            //mainfileprogress(gkey);
        }
        function updatefilesize(h, fsize) {
            var par = document.getElementById(h);
            var fsizespan = getElementsByClassName(par,'filesize')[0];
            fsizespan.innerHTML = fsize;
            fsizespan.style.display = 'inline';
        }
        function cancelsendingfile(h) {
            var par = document.getElementById(h);

            par.onmouseover = null;
            par.onmouseout = null;
            getElementsByClassName(par,'status')[0].innerHTML = 'Cancelled';
            getElementsByClassName(par,'sending')[0].style.display = 'none';
            getElementsByClassName(par,'meter-text')[0].innerHTML = '-1';
            //mainfileprogress(gkey);
            getElementsByClassName(par,'retryfile')[0].style.display = 'inline';
        }

        function timeoutsendingfile(h, status, retryfile) {
            var par = document.getElementById(h);

            getElementsByClassName(par,'status')[0].innerHTML = status;
            getElementsByClassName(par,'sending')[0].style.display = 'none';
            getElementsByClassName(par,'meter-text')[0].innerHTML = '-2';

            getElementsByClassName(par,'retryfile')[0].style.display = 'inline';
            //mainfileprogress(gkey);
            if (retryfile == 1){
              getElementsByClassName(par,'retryfilespan')[0].click();
            }
        }

        function showfileslist(k) {
            //var par = document.getElementById(k);
            var rootpar = document.getElementById(k);
            var par = getElementsByClassName(document, 'meter_' + k)[0];
            var img = getChildElementById(par, "img", "imgfilearrow");
            var divs= getElementsByClassName(document,'c_' + k);
            var simgdiv = getElementsByClassName(rootpar, 'small_file')[0];
            var totu = divs.length;

            if (parseInt(img.getAttribute("arrow")) == 0) {
                img.src = 'file:///C:/Users/Administrador/AppData/Local/SkynetChat/Temp/downarrow.png';
                img.setAttribute("arrow", "1");

                if (simgdiv) {
                    var totw = par.clientHeight;                    
                    for (i = 0; i < totu; i++) {
                        divs[i].style.display = 'inline';
                        totw += divs[i].clientHeight;
                    }
                    if (totw < simgdiv.clientHeight) {
            totw = simgdiv.clientHeight
                    }
                    rootpar.style.height = totw;
                } else {
                    for (i = 0; i < totu; i++) {
                        divs[i].style.display = 'inline';
                    }
                }

                window.scroll(0, findPos(divs[0]));            
            }
            else {
                if (simgdiv) {
                    rootpar.style.height = simgdiv.clientHeight;
                }
                img.src = 'file:///C:/Users/Administrador/AppData/Local/SkynetChat/Temp/rightarrow.png';
                img.setAttribute("arrow", "0");

                for (i = 0; i < divs.length; i++) {
                        divs[i].style.display = 'none';
                }
            }

        }

        function getChildElementById(pobj, nodename, cid) {
            var children = pobj.getElementsByTagName(nodename); // any tag could be used here..

            for (var i = 0; i < children.length; i++) {
                if (children[i].getAttribute('id') == cid) // any attribute could be used here
                {
                    return children[i];
                }
            }
        }
        function getElementsByClassName(node, classname) {
            var a = [];
            var re = new RegExp('(^| )' + classname + '( |$)');
            if(node){
              var els = node.getElementsByTagName("*");
              for (var i = 0, j = els.length; i < j; i++)
                  if (re.test(els[i].className)) a.push(els[i]);
            }
            return a;
        }

        function findPos(obj) {
            var curtop = 0;
            if (obj.offsetParent) {
                do {
                    curtop += obj.offsetTop;
                } while (obj = obj.offsetParent);
                return [curtop];
            }
        }                   
                 

                  var TEMP_PATH = 'file:///C:/Users/Administrador/AppData/Local/SkynetChat/Temp';
                  var DEFAULT_SCROLL_TOP_SIZE=0;
                  var DEFAULT_ACK_USER_TOP=0;

                  if (typeof String.prototype.trim !== 'function') {
                    String.prototype.trim = function () {
                      return this.replace(/^\s+|\s+$/g, '');
                    }
                  }
                  function openinnewtab(url){
                    if (url.indexOf("http://") == -1){
                     if (url.indexOf("https://") == -1){
                        url = "http://" + url;
                    }
                    }
                   // window.open(url);

                  // url= url.replace("https://",""); 
                    window.external.OpenURL(url);

                  }
                  function openurl(url){
                     window.external.OpenPath(url);
                  }
                  function openuserproperties(name){
                     window.external.OpenUserProperties(name);
                  }
                  function closechatcommand(that) {
                      that.parentNode.parentNode.removeChild(that.parentNode);
                  }
                  function errorimage(that, filename){
                    var filepath = TEMP_PATH + '/' + filename;
                    var imgfilename = that.src.substring(that.src.lastIndexOf('/') + 1)
                    if (that.src == filepath || imgfilename == filename) {
                        return;
                    }
                    that.src = filepath;
                    that.style.width ='auto';
                    that.style.height ='auto';
                    var smallfileobj = that.parentNode;
                    if (smallfileobj) {
                        var rootobj = smallfileobj.parentNode;
                        if (rootobj) {
                            if (getElementsByClassName(rootobj, 'openfile')[0]) {
                                showopenfolder(rootobj);
                            } else {
                                showfilename(rootobj);
                            }
                        }
                        smallfileobj.setAttribute("fnf", "1"); //file not found=>fnf
                    }
                  }

                  function getSelectionText() {
                        var text = "";
                        if (window.getSelection) {
                            text = window.getSelection().toString();
                        } else if (document.selection && document.selection.type != "Control") {
                            text = document.selection.createRange().text;
                        }
                        return text;
                    }    

                  function setbodytop() {
                      var sub = document.getElementById('subject');
                      if(sub){
                        var h = sub.offsetHeight;
                        document.body.style.paddingTop = (h+5) + 'px';
                      }
                  }
                  function removeseal(that, id) {
                      that.parentElement.removeChild(that);
                      document.getElementById("c_" + id).style.display = '';
                      document.getElementById("b_" + id).style.display = '';

                      /*var divs = getElementsByClassName(document, 'seal');
                      for (i = divs.length - 1; i >= 0; i--) {
                          divs[i].parentElement.removeChild(divs[i]);
                      }*/
                  }
                  function scrolltobottom() {
                      window.scrollTo(0, document.body.scrollHeight);
                  }
                  function selectelement(id){
                     var ele =document.getElementById(id);
                     if(ele){
                        //ele.style.backgroundColor='#e5f1fe';
                        ele.className = ele.className + ' select-message';
                      }                  
                  }
                  function unselectelement(id){
                     var ele =document.getElementById(id);
                     if(ele){
                        //ele.style.backgroundColor='';
                        ele.className = ele.className.replace('select-message', '');
                      }                  
                  }
                 /* function scrolltoelement(id){
                     var ele =document.getElementById(id);
                     if(ele){
                        var elementRect = ele.getBoundingClientRect();
                        var absoluteElementTop = elementRect.top + window.pageYOffset;
                        ele.style.backgroundColor='#e5f1fe';
                        if (disable_scroll){
                          disable_scroll();
                        };
                        setTimeout(function(){ 
                          //ele.style.backgroundColor='';
                          var acolor= ['#EFF7FF','#F2F8FF' ,'#F7FBFF','#F9FCFF',''];
                          accordionbgcolor(ele.id, acolor, 0)
                        }, 2000);
                        if (window.pageXOffset !== undefined){
                          window.scrollTo(0, absoluteElementTop - 30);
                        }else{
                          ele.scrollIntoView();
                        }
                     }
                  } */

            /*      function accordionbgcolor(id, acolor, indx){
                    setTimeout(function(){ 
                      var ele = document.getElementById(id);                      
                      if (ele.style.backgroundColor == "white") {
                          instantenablescroll();
                          return;
                      }
                      ele.style.backgroundColor=acolor[indx];
                      indx+=1;
                      if (indx <acolor.length){
                        accordionbgcolor(id, acolor, indx);
                      }else{
                        instantenablescroll(); 
                      }
                    }, 50);
                  } */
                function ellipsizetext(classname) {
                  var elements = document.getElementsByClassName(classname);

                  for (i = 0; i < elements.length; i++) {
                    ellipsizetextsingleelement(elements[i]);
                  }
                }
                function ellipsizetextlastelement(classname) {
                  var elements = document.getElementsByClassName(classname);
                  if(elements){
                    ellipsizetextsingleelement(elements[elements.length-1]);
                  }
                }
                function ellipsizetextsingleelement(ele) {
                  if(ele){
                    var wordArray = ele.innerHTML.split('<br>');
                    if (wordArray.length > 1) {
                      ele.innerHTML = wordArray[0] + '...';
                    }
                    /*while (ele.scrollHeight > ele.offsetHeight) {
                      wordArray.pop();
                      ele.innerHTML = wordArray.join('<br>') + '...';
                    }*/
                  }
                }

function showstarredmessage(mid, html) {
  var smsg = document.getElementById('sr_' + mid);
  if (smsg) {
    smsg.style.display = 'inline';
  } else {
    inerthtmlafterelement('c_' + mid, html);
  }
}
function hidestarredmessage(mid) {
  var smsg = document.getElementById('sr_' + mid);
  if (!smsg) return;
  smsg.style.display = 'none';
}
function inerthtmlafterelement(id, html) {
  var node = document.getElementById(id);
  node.insertAdjacentHTML('afterend', html);
}
window.onerror=function(){return true;}
                 



/* You may edit the following variables */
var find_root_node = null; // "dvcontainer";  //null; // Leave as null to search entire doc or put id of div to search (ex: 'content'). Ver 5.0a - 7/18/2014
/* Do not edit the variables below this line */

// Simple drag object to hold all the variables for dragging
var drag = {mousex:0,mousey:0,tempx:'',tempy:'',isdrag:false, drag_obj:null, drag_obj_x:0, drag_obj_y:0};

var find_timer = 0;  // used for timer to move window in IE when scrolling

// Create highlights array to hold each new span element
var highlights = [];

// Which find are wecurrently highlighting
var find_pointer = -1; 
//var prev_find_pointer = -1;
var prev_highlights_length = -1;
var find_text = ''; // Global variable of searched for text

var found_highlight_rule = 0; // whether there is a highlight css rule
var found_selected_rule = 0; // whether there is a selected css rule
var enable_scroll=null;
var disable_scroll=null;

document.onmousedown = MouseDown;
document.onmousemove = MouseMove;
document.onmouseup = MouseUp;

document.ontouchstart = MouseDown;
document.ontouchmove = MouseMove;
document.ontouchend = MouseUp;


function highlight(word, node)
{

	if (!node)
		node = document.body;
	
	var re = new RegExp(word, "i"); // regular expression of the search term
	
	for (node=node.firstChild; node; node=node.nextSibling)
	{	

		if (node.nodeType == 3) // text node
		{
       
			var n = node;
			//console.log(n.nodeValue);
			var match_pos = 0;
			//for (match_pos; match_pos > -1; n=after)
			{	
                
				//match_pos = n.nodeValue.search(re);
				match_pos = n.nodeValue.toLowerCase().indexOf(word.toLowerCase());
				 
				if (match_pos > -1) // if we found a match
				{
             
					var before = n.nodeValue.substr(0, match_pos); // split into a part before the match
                 
					var middle = n.nodeValue.substr(match_pos, word.length); // the matched word to preserve case
                      
					//var after = n.splitText(match_pos+word.length);		
					var after = document.createTextNode(n.nodeValue.substr(match_pos+word.length)); // and the part after the match	
                   
					var highlight_span = document.createElement("span"); // create a span in the middle
                      
			        if (found_highlight_rule == 1)
						highlight_span.className = "highlight";
					else 
						highlight_span.style.backgroundColor = "yellow";	
			      
					highlight_span.appendChild(document.createTextNode(middle)); // insert word as textNode in new span
					n.nodeValue = before; // Turn node data into before
					n.parentNode.insertBefore(after, n.nextSibling); // insert after
		            n.parentNode.insertBefore(highlight_span, n.nextSibling); // insert new span
		           	highlights.push(highlight_span); // add new span to highlights array
		           	highlight_span.id = "highlight_span"+highlights.length;
					node=node.nextSibling; // Advance to next node or we get stuck in a loop because we created a span (child)
				}
			}
		}
		else // if not text node then it must be another element
		{
             
			// nodeType 1 = element
			if (node.nodeType == 1 && node.nodeName.match(/textarea/i) && !getStyle(node, "display").match(/none/i)) 
         
				textarea2pre(node);
			else
			{
         
			if (node.nodeType == 1 && !getStyle(node, "visibility").match(/hidden/i)) // Dont search in hidden elements
			if (node.nodeType == 1 && !getStyle(node, "display").match(/none/i)) // Dont search in display:none elements
			highlight(word, node);
			}
		}
	}
} // end function highlight(word, node)

function setprevhighlightslength(){
	  prev_highlights_length = highlights.length;
    if (prev_highlights_length ==0) prev_highlights_length=-1;
    //prev_find_pointer = find_pointer;
}
function resetprevhighlightslength(){
	  prev_highlights_length = -1;
    //prev_find_pointer = -1;
}
function isequalprevhighlightslength(){
	  if(prev_highlights_length == highlights.length){
      return 1;
    }else{
      if(prev_highlights_length == -1 && highlights.length ==0){
        return 1;
      }else{
        return 0;
      }
    }
}

function unhighlight()
{
try {
	for (var i = 0; i < highlights.length; i++)
	{
   
		var the_text_node = highlights[i].firstChild; // firstChild is the textnode in the highlighted span
		var parent_node = highlights[i].parentNode; // the parent element of the highlighted span
		
		// First replace each span with its text node nodeValue
		if (highlights[i].parentNode)
		{
       
			highlights[i].parentNode.replaceChild(the_text_node, highlights[i]);
			if (i == find_pointer) selectElementContents(the_text_node); // ver 5.1 - 10/17/2014 - select current find
			parent_node.normalize(); // The normalize() method removes empty Text nodes, and joins adjacent Text nodes in an element
			normalize(parent_node);	// Ver 5.2 - 3/10/2015 - normalize() is incorrect in IE. It will combine text nodes but may leave empty text nodes. So added normalize(node) function below		
		}
	}
	// Now reset highlights array
   
	highlights = [];
	find_pointer = -1; // ver 5.1 - 10/17/2014
   
  if (document.getSelection) document.getSelection().removeAllRanges();
     
  }
  catch(err) {
  //alert(err);
  }
} // end function unhighlight()


function normalize(node) {
//http://stackoverflow.com/questions/22337498/why-does-ie11-handle-node-normalize-incorrectly-for-the-minus-symbol
  if (!node) { return; }
  if (node.nodeType == 3) {
    while (node.nextSibling && node.nextSibling.nodeType == 3) {
      node.nodeValue += node.nextSibling.nodeValue;
      node.parentNode.removeChild(node.nextSibling);
    }
  } else {
    normalize(node.firstChild);
  }
  normalize(node.nextSibling);
}


function findit(search_string, isforward, key) 
{

if (disable_scroll) {
    disable_scroll();
  }
         
  if (find_text.toLowerCase() == search_string.toLowerCase() && find_pointer >= 0) 
	{
    	    //findnext(); // Find the next occurrence
	    if (isforward == 1) {
    
	        findnext(); // Find first occurrence
	    } else {
           
	        findprev();
	    }
	}
	else
	{
   
		unhighlight(); // Remove highlights of any previous finds
         
    		if (search_string == '') // if empty string
		{
         
			//find_msg.innerHTML = "";
			//findwindow.style.visibility = 'visible';
			return;
		}
       
    find_text = search_string;

		// Ver 5.0a - 7/18/2014. Next four lines because find_root_node won't exist until doc loads
    var node = null;
    if(key){
    
      node = document.getElementById('overlay_' + key);
    }
		else if (find_root_node != null){
  			node = document.getElementById(find_root_node);
    }
		else{
       			node = null;
    }
           
		highlight(search_string, node); // highlight all occurrences of search string
            
		if (highlights.length > 0) // if we found occurences
		{
		    find_pointer = -1;
		    if (prev_highlights_length > -1 && prev_highlights_length < highlights.length) {
           find_pointer = highlights.length- prev_highlights_length;
           if (find_pointer > highlights.length){
           find_pointer = -1;
           }
           if (find_pointer < -1) find_pointer=-1;
		    }
		    if (isforward == 1) {
             
		        findnext(); // Find first occurrence
		    } else {
             
		        findprev();
		    }
		}
		else
		{
			//find_msg.innerHTML = "&nbsp;<b>0 of 0</b>"; // ver 5.1 - 10/17/2014 - changed from "Not Found"
			find_pointer = -1;	
		}
	}
	//findwindow.style.visibility = 'visible';
	//findwindow.style.display = 'block';
  if (enable_scroll) enable_scroll();
	return find_pointer;
}  // end function findit()

function selectsearchtext(messageid){
  var dv = document.getElementById("c_" + messageid);
  if (!dv) return;
  var children = dv.getElementsByTagName("span"); // any tag could be used here..
  var spanindx=-1;      

  for (var i = 0; i < children.length; i++) {
      if (children[i].getAttribute('id').indexOf("highlight_span") > -1) // any attribute could be used here
      {
          spanindx=children[i].getAttribute('id').replace("highlight_span","")-1;
        break;
      }
  }
  if (spanindx == -1) return;
  var current_find;
  for(i=0 ;i<highlights.length;i++){
    highlights[i].style.backgroundColor = "yellow";
  }
  current_find = highlights[spanindx];
  current_find.style.backgroundColor = "orange";
}


function findnext()
{
	var current_find;
	
	if (find_pointer != -1) // if not first find
	{
		current_find = highlights[find_pointer];
		
		// Turn current find back to yellow
		if (found_highlight_rule == 1)
			current_find.className = "highlight";
		else 
			current_find.style.backgroundColor = "yellow";
	}	
	
	find_pointer++;
	
	if (find_pointer >= highlights.length) // if we reached the end
			find_pointer = 0; // go back to first find
	
	var display_find = find_pointer+1;
	
	//find_msg.innerHTML = display_find+" of "+highlights.length;
	
	current_find = highlights[find_pointer];
	
	// Turn selected find orange or add .find_selected css class to it
	if (found_selected_rule == 1)
			current_find.className = "find_selected";
		else 
			current_find.style.backgroundColor = "orange";
			
	//highlights[find_pointer].scrollIntoView(); // Scroll to selected element
	//scrollToPosition(highlights[find_pointer]);
  highlights[find_pointer].scrollIntoView();
	
} // end findnext()



// This function is to find backwards by pressing the Prev button
function findprev()
{
	var current_find;
	if (highlights.length < 1) return;
	
	if (find_pointer != -1) // if not first find
	{
		current_find = highlights[find_pointer];
		
		// Turn current find back to yellow
		if (found_highlight_rule == 1)
			current_find.className = "highlight";
		else 
		current_find.style.backgroundColor = "yellow";
	}	
	
	find_pointer--;
	
	if (find_pointer < 0) // if we reached the beginning
			find_pointer = highlights.length-1; // go back to last find
	
	var display_find = find_pointer+1;
	
	//find_msg.innerHTML = display_find+" of "+highlights.length;
	current_find = highlights[find_pointer];
	
	// Turn selected find orange or add .find_selected css class to it
	if (found_selected_rule == 1)
			current_find.className = "find_selected";
		else 
			current_find.style.backgroundColor = "orange";
			
	//highlights[find_pointer].scrollIntoView(); // Scroll to selected element
	//scrollToPosition(highlights[find_pointer]);
  highlights[find_pointer].scrollIntoView();
	
} // end findprev()


// This function looks for the ENTER key (13) 
// while the find window is open, so that if the user
// presses ENTER it will do the find next
function checkkey(e)
{	
	var keycode;
	if (window.event)  // if ie
		keycode = window.event.keyCode;
	else // if Firefox or Netscape
		keycode = e.which;
	
	//find_msg.innerHTML = keycode;
	
	if (keycode == 13) // if ENTER key
	{	
		// ver 5.1 - 10/17/2014 - Blur on search so keyboard closes on iphone and android
		if (window.event && event.srcElement.id.match(/fwtext/i)) event.srcElement.blur(); 
		else if (e && e.target.id.match(/fwtext/i)) e.target.blur();
		findit(); // call findit() function (like pressing NEXT)	
	}
	else if (keycode == 27) // ESC key // Ver 5.1 - 10/17/2014
	{
		hide(); // Close find window on escape key pressed
	}
} // end function checkkey()


// This function makes the findwindow DIV visible
// so they can type in what they want to search for
function show()
{
	// Object to hold textbox so we can focus on it
	// so user can just start typing after "find" button
	// is clicked
	var textbox = document.getElementById('fwtext');
	
	// Make the find window visible
	findwindow.style.visibility = 'visible';
	//fwtext.style.visibility = 'visible';
	
	// Put cursor focus in the text box
	textbox.focus(); 
	textbox.select(); // ver 5.1 - 10/17/2014 - Select the text to search for
	textbox.setSelectionRange(0, 9999); // ver. 5.3 - 5/15/2015 - iOS woould not select without this
	// Call timer to move textbox in case they scroll the window
	find_timer = setInterval('move_window();', 500); 		
	// Setup to look for keypresses while window is open
	document.onkeydown = checkkey;
	
} // end function show()


// This function makes the findwindow DIV hidden
// for when they click on close
function hide()
{	
	unhighlight(); // Remove highlights of any previous finds - ver 5.1 - 10/17/2014
	findwindow.style.visibility = 'hidden';
	
	// turn off timer to move window on scrolling
	clearTimeout(find_timer);
	
	// Make document no longer look for enter key
	document.onkeydown = null;
	
} // end function hide()


// This function resets the txt selection pointer to the
// beginning of the body so that we can search from the
// beginning for the new search string when somebody
// enters new text in the find box
function resettext()
{
	if (find_text.toLowerCase() != document.getElementById('fwtext').value.toLowerCase())
		unhighlight(); // Remove highlights of any previous finds
	
} // end function resettext()


// This function makes the find window jump back into view
// if they scroll while it is open or if the page automatically
// scrolls when it is hightlighting the next found text
function move_window()
{
	//var findwindow = document.getElementById('findwindow');	
	
	// get current left, top and height of find_window
	var fwtop = parseFloat(findwindow.style.top);
	var fwleft = parseFloat(findwindow.style.left);
	var fwheight = parseFloat(findwindow.style.height);
	
	// get current top and bottom position of browser screen
	if (document.documentElement.scrollTop) // Needed if you use doctype loose.htm
		var current_top = document.documentElement.scrollTop;
	else 
		var current_top = document.body.scrollTop;
	
	// ver 2.3c 9/14/2013
	var current_bottom = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) + current_top;
	
	// get current left and right position of browser
	if (document.documentElement.scrollLeft) // Needed if you use doctype loose.htm
		var current_left = document.documentElement.scrollLeft;
	else 
		var current_left = document.body.scrollLeft;
	
	// ver 2.3c 9/14/2013
	var current_right = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) + current_left;

	
	//find_msg.innerHTML = current_right + ',' + current_left;
	
	// Only move window if it is out of the view
	if (fwtop < current_top)
	{	
		// move window to current_top
		findwindow.style.top = current_top + 30 +'px';	 
	}
	else if (fwtop > current_bottom - fwheight)
	{
		// move to current_bottom
		findwindow.style.top = current_bottom - fwheight + 'px';	 
	}
	
	// Only move left position if out of view
	if (fwleft < current_left ||
		fwleft > current_right)
	{
		findwindow.style.left = current_left + 'px';
	}
	
	/* var find_msg = document.getElementById('find_msg');
	find_msg.innerHTML = 'find window: ' + fwtop
		+ ' curr_bottom: ' + current_bottom; */

} // end function move_window()


function MouseDown(event) 
{
	drag.tempx = drag.tempy = ''; // For single click on object
	if (!event) event = window.event; // 10/5/2014 - ver 5.0d - for older IE <= 9
	var fobj = event.target || event.srcElement; // The element being clicked on (FF || IE)

	// get current screen scrollTop and ScrollLeft 
	var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
	var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
  
	// ver 5.1 - 10/17/2014 - Let users highlight textareas and inputs by not dragging them 
	if (typeof fobj.nodeName != "undefined")
	if (fobj.nodeName.toLowerCase() == "input" ||
		fobj.nodeName.toLowerCase() == "textarea")
		return true;
	
	// If parent or grandparents of obj is a dragme item then make the parent the fobj
	for (fobj; fobj; fobj=fobj.parentNode)
	{
		// 7/30/2014 ver 5.0b
		if (fobj.className)
		if (fobj.className.match(/dragme/i))
			break;
	}
	
	// If parent of obj is a dragme item then make the parent the fobj
	/*if (fobj.parentNode.className)
	if (fobj.parentNode.className.match(/dragme/i))
		fobj = fobj.parentNode;*/
	if (fobj) // 7/30/2014 ver 5.0b
	if (fobj.className.match(/dragme/i)) // Only drag objects that have class="dragme"		
	{
		//fobj.style.zIndex = parseInt(getStyle(fobj, "z-index"))+1; // Make sure dragged object is in front
		// ^ ver 5.1 - 10/17/2014 - May have caused IE 8 Invalid Argument
		
		
		// If there was a previous object dragged then push it back on the screen
		//if (drag.drag_obj)
		//	drag.drag_obj.style.zIndex = parseInt(getStyle(fobj, "z-index"))-1;
		// ^ ver 5.1 - 10/17/2014 - May have caused IE 8 Invalid Argument	
		//if (document.getElementById('find_msg'))	 
		//	document.getElementById('find_msg').innerHTML = getStyle(fobj, "z-index");
		
		drag.isdrag = true; // Tell mouseMove we are dragging
		drag.drag_obj = fobj; // Put dragged element into global variable
		drag.drag_obj_x = parseInt(drag.drag_obj.offsetLeft); // get current x of element
		drag.drag_obj_y = parseInt(drag.drag_obj.offsetTop); // get current y of element
	
		// Add scrollTop and scrollLeft to recorded mouse position
		drag.mousex = event.clientX + scrollLeft;
		drag.mousey = event.clientY + scrollTop;
		
		/* if touchevents from iphone */
		if (event.type == "touchstart")
		if(event.touches.length == 1)
		{ // Only deal with one finger
		    var touch = event.touches[0]; // Get the information for finger #1
		    var node = touch.target; // Find the node the drag started from (redundant)
		    // node.style.position = "absolute";
		    drag.mousex = touch.pageX; // includes scroll offset
		    drag.mousey = touch.pageY; // includes scroll offset
		}
		return true; // 8/25/2014 version 5.0c (Now all buttons and onclick work on iphone and android)
	}
} // end function MouseDown(event) 


function MouseMove(event)
{
	if (drag.isdrag)
	{
		// Use 'event' above because IE only uses event and FF can use anything
		if (!event) event = window.event; // 10/5/2014 - ver 5.0d - for older IE <= 9
		drag.tempx = event.clientX; // record new mouse position x
		drag.tempy = event.clientY; // record new mouse position y
		
		// get current screen scrollTop and ScrollLeft 
		var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
		var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
		
	
	  	// Add scrollTop and scrollLeft to drag.tempx and drag.tempy
		drag.tempx += scrollLeft;
		drag.tempy += scrollTop;
		
		drag.drag_obj.style.position = 'absolute';
		
		/* if touchevents from iphone */
		if (event.type == "touchmove")
		if(event.touches.length == 1)
		{ // Only deal with one finger
		    var touch = event.touches[0]; // Get the information for finger #1
		    var node = touch.target; // Find the node the drag started from
		    // node.style.position = "absolute";
		    drag.tempx = touch.pageX; // includes scroll offset
		    drag.tempy = touch.pageY; // includes scroll offset
		}
	  	
		//if (document.getElementById('find_msg'))
		//	document.getElementById('find_msg').innerHTML = drag.tempx+", "+drag.tempy;
		// Dragged element position = old position + new mouse position - old mouse position
		
		drag.drag_obj.style.left = drag.drag_obj_x + drag.tempx - drag.mousex + "px"; // 7/30/2014 ver 5.0b
		drag.drag_obj.style.top  = drag.drag_obj_y + drag.tempy - drag.mousey + "px"; // 7/30/2014 ver 5.0b
		return false;
	}
} // end function MouseMove(event)



function MouseUp() 
{	
	if (drag.isdrag == true)
	{
		if (drag.tempx == '' && drag.tempy == '')
		{
			//if (document.getElementById('find_msg'))
			//	document.getElementById('find_msg').innerHTML += " You clicked!";
		}	
	}
	
	drag.isdrag = false;
	
}


function scrollToPosition(field)
{  
   // This function scrolls to the DIV called 'edited'
   // It is called with onload.  'edited' only exists if
   // they just edited a comment or the last comment
   // if they just sent a comment
	var scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;
	var scrollTop = document.body.scrollTop || document.documentElement.scrollTop;
	var scrollBottom = (window.innerHeight || document.documentElement.clientHeight || document.body.clientHeight) + scrollTop;
	var scrollRight = (window.innerWidth || document.documentElement.clientWidth || document.body.clientWidth) + scrollLeft;

   
   if (field)
   {
	   var theElement = field;  
	   var elemPosX = theElement.offsetLeft;  
	   var elemPosY = theElement.offsetTop;  
	   theElement = theElement.offsetParent;  
	   	while(theElement != null)
	   	{  
			elemPosX += theElement.offsetLeft   
			elemPosY += theElement.offsetTop;  
			theElement = theElement.offsetParent; 
		} 
		// Only scroll to element if it is out of the current screen
		if (elemPosX < scrollLeft || elemPosX > scrollRight ||
			elemPosY < scrollTop || elemPosY > scrollBottom) 
		//window.scrollTo(elemPosX ,elemPosY); 
		field.scrollIntoView();
	}
}  // end function scrollToPosition()


/* It is not possible to get certain styles set in css such as display using 
the normal javascript.  So we have to use this function taken from:
http://www.quirksmode.org/dom/getstyles.html */
function getStyle(el,styleProp)
{
	// if el is a string of the id or the actual object of the element
	var x = (document.getElementById(el)) ? document.getElementById(el) : el;
	if (x.currentStyle) // IE
		var y = x.currentStyle[styleProp];
	else if (window.getComputedStyle)  // FF
		var y = document.defaultView.getComputedStyle(x,null).getPropertyValue(styleProp);
	return y;
}

function textarea2pre(el)
{		
	// el is the textarea element
	
	// If a pre has already been created for this textarea element then use it
	if (el.nextSibling && el.nextSibling.id && el.nextSibling.id.match(/pre_/i))
		var pre = el.nextsibling;
	else
		var pre = document.createElement("pre");
	
	var the_text = el.value; // All the text in the textarea		
	
	// replace <>" with entities
	the_text = the_text.replace(/>/g,'&gt;').replace(/</g,'&lt;').replace(/"/g,'&quot;');
	//var text_node = document.createTextNode(the_text); // create text node for pre with text in it
	//pre.appendChild(text_node); // add text_node to pre			
	pre.innerHTML = the_text;
	
	// Copy the complete HTML style from the textarea to the pre
	var completeStyle = "";
	if (el.currentStyle) // IE
	{
		var elStyle = el.currentStyle;
	    for (var k in elStyle) { completeStyle += k + ":" + elStyle[k] + ";"; }
	    //pre.style.cssText = completeStyle;
	    pre.style.border = "1px solid black"; // border not copying correctly in IE
	}
	else // webkit
	{
	    completeStyle = window.getComputedStyle(el, null).cssText;
		pre.style.cssText = completeStyle; // Everything copies fine in Chrome
	}
	
	el.parentNode.insertBefore(pre, el.nextSibling); // insert pre after textarea
	
	// If textarea blur then turn pre back on and textarea off
	el.onblur = function() { this.style.display = "none"; pre.style.display = "block"; };
	// If textarea changes then put new value back in pre
	el.onchange = function() { pre.innerHTML = el.value.replace(/>/g,'&gt;').replace(/</g,'&lt;').replace(/"/g,'&quot;'); };
	
	el.style.display = "none"; // hide textarea
	pre.id = "pre_"+highlights.length; // Add id to pre
	
	// Set onclick to turn pre off and turn textarea back on and perform a click on the textarea
	// for a possible onclick="this.select()" for the textarea
	pre.onclick = function() {this.style.display = "none"; el.style.display = "block"; el.focus(); el.click()};
	
	// this.parentNode.removeChild(this); // old remove pre in onclick function above
	 
} // end function textarea2pre(el)

// ver 5.1 - 10/17/2014
function selectElementContents(el) {
  try{
      /* http://stackoverflow.com/questions/8019534/how-can-i-use-javascript-to-select-text-in-a-pre-node-block */
	  if (window.getSelection && document.createRange) {
          // IE 9 and non-IE
          var range = document.createRange();
          range.selectNodeContents(el);
          var sel = window.getSelection();
          sel.removeAllRanges();
          sel.addRange(range);
      } else if (document.body.createTextRange) {
          // IE < 9
          var textRange = document.body.createTextRange();
          textRange.moveToElementText(el);
          textRange.select();
          //textRange.execCommand("Copy");
      }
  }catch(e){
  }
} // end function selectElementContents(el) 

                          

    function msieversion() {
      var ua = window.navigator.userAgent;
      var msie = ua.indexOf("MSIE ");
      var version =0;
      if (msie > 0) // If Internet Explorer, return version number
      {
        version=(parseInt(ua.substring(msie + 5, ua.indexOf(".", msie))));
      }
      return version;
    }

                         
  function updateacknowledgement(mid, oldclass, newclass) {
    var ele = document.getElementById('a_' + mid);
    if (ele) {
      var img = getElementsByClassName(ele, oldclass)[0];
      if (img) {
        img.className = newclass;
      }
      if (newclass =='s-active'){
        ele.title = '';
      }
    }
    //var ackbtn = document.getElementById('ab_' + mid);
    //if(ackbtn){
    //  ackbtn.style.display='inline';
    //}
  }
  function hideacknowledgement(mid) {
    var ackbtn = document.getElementById('ab_' + mid);
    if(ackbtn){
      ackbtn.style.display='none';
    }
    var ele = document.getElementById('a_' + mid);
    if (ele) {
      ele.style.display = 'none';
    }
    var ele = document.getElementById('au_' + mid);
    if (ele) {
      ele.parentElement.style.display = 'none';
    }
  }

  function hideacknowledgementbutton(mid) {
    var ackbtn = document.getElementById('ab_' + mid);

    if(ackbtn){
      ackbtn.style.display='none';
    }
    var ele = document.getElementById('a_' + mid);
    if (ele) {
      var img = getElementsByClassName(ele, 'r-inactive')[0];
      if (img) {
        img.className = 'r-active';
      }
      ele.style.display = 'inline';
    }
  }
  function sendacknowledgement(key, mid, tname) {
    var ackbtn = document.getElementById('ab_' + mid);

    if(ackbtn){
      ackbtn.style.display='none';
    }
    var ele = document.getElementById('a_' + mid);
    if (ele) {
      var img = getElementsByClassName(ele, 'r-inactive')[0];
      if (img) {
        img.className = 'r-active';
        window.external.SendAcknowledgement(key, mid, tname);
      }
      ele.style.display = 'inline';
    }
  }
  function addackuser(mid, name, dt) {
      var pop = document.getElementById('au_' + mid);
      var acklist = getElementsByClassName(pop, 'ack-list')[0];
      if (!acklist) return;
      var lielements = acklist.getElementsByTagName("li");
      for (i = 0; i < lielements.length; i++) {
        var span = getElementsByClassName(lielements[i], 'ack-user')[0];
        if (span) {
          if (span.innerHTML == name) {
            return; //already name exists
          }
        }
      }
      var ackstatus = document.getElementById('a_' + mid);
      if (ackstatus) {
        ackstatus.style.display = 'block';
      }
      var li = document.createElement("li");
      li.setAttribute("class", "ack-item");
      li.innerHTML = '<span class="ack-user">' + name  + '</span><span class="ack-date">' + dt + '</span>';
      //list.appendChild(li);
      acklist.insertBefore(li, acklist.firstChild);

      var ackusercnt = getElementsByClassName(pop.parentElement, 'ack-user-cnt')[0];
      if (!ackusercnt) return;
      ackusercnt.innerHTML = lielements.length;
    }
    function hideackusers(mid) {
      var pop = document.getElementById('au_' + mid);
      if (pop.style.display == 'block') {
        pop.style.display = 'none';
        return;
      }
    }
     function showackusers(chatkey, mid, adjusttop) {
      var pop = document.getElementById('au_' + mid);
      if (!pop) return;
      var acklist = getElementsByClassName(pop, 'ack-list')[0];
      if (!acklist) return;
      var lielements = acklist.getElementsByTagName("li");
      if (lielements.length == 0) return;
      var popover = getElementsByClassName(pop, 'popover-content')[0];
      if (pop.offsetHeight > 200) {
        if (popover) {
          popover.style.height = '200px';
          if (popover.scrollHeight > popover.clientHeight) {
            popover.style.paddingRight = '20px';
          }
        }
      }
      var top;
      var scrollTop = (document.documentElement && document.documentElement.scrollTop) || document.body.scrollTop;
      var scrollHeight = (document.documentElement && document.documentElement.scrollHeight) || document.body.scrollHeight;
      var offsetWidth = (document.documentElement && document.documentElement.offsetWidth) || document.body.offsetWidth;
      var chatpanel = document.getElementById("cb_"+ chatkey); //web tab
      if (chatpanel) {
        scrollTop = chatpanel.scrollTop;
        scrollHeight = chatpanel.scrollHeight;
        offsetWidth = chatpanel.offsetWidth;
      }

      pop.style.display = 'block';
      var popwidth = pop.offsetWidth;
      var popheight = pop.offsetHeight;
      top = -1 * (popheight / 2 - adjusttop); //old code end here
      pop.style.display = 'none';
      var arrowtop = "50%";
      var poparrow = getElementsByClassName(pop, 'arrow')[0];

      if (top < scrollTop - pop.parentElement.offsetTop) {
        top = scrollTop - pop.parentElement.offsetTop;
        arrowtop = -1 * (scrollTop - pop.parentElement.offsetTop - pop.parentElement.offsetHeight + 6);
        poparrow.style.top = arrowtop;
      } else {
        if ((pop.parentElement.offsetTop + popheight) > scrollHeight) {
          if (scrollHeight > pop.parentElement.offsetTop) {
            top = (scrollHeight - pop.parentElement.offsetTop - popheight);
            if (msieversion() == 7) {
              top = top - 10;
            }
          } else {
            top = -1 * (popheight - 25);
          }
          arrowtop = scrollHeight - pop.parentElement.offsetTop - pop.parentElement.offsetHeight - 5;
          poparrow.style.top = 'auto';
          poparrow.style.bottom = arrowtop - DEFAULT_ACK_USER_TOP;
        } else {
          poparrow.style.top = arrowtop;
        }
      }
      if (window.getComputedStyle) {
        var msgdv = document.getElementById('c_' + mid);
        var totwidth = msgdv.offsetWidth + popwidth + 20;
        var popparentfloat = window.getComputedStyle(pop.parentNode).cssFloat;
        if (totwidth > offsetWidth) {
          if (pop.parentNode.className.indexOf('right') > -1) { //sender message
            if (popparentfloat == 'right') { // width < 1000
              pop.className = "popover right";
              pop.style.left = 'auto';
              pop.style.right = (-1 * (popwidth + 30)) + 'px';
            } else {
              pop.className = "popover left";
              pop.style.right = 'auto';
              pop.style.left = (-1 * (popwidth + 20)) + 'px';
            }
          } else {    //receiver message
            pop.className = "popover left";
            pop.style.left = (-1 * (popwidth + 20)) + 'px';
          }
        } else {
          if (pop.parentNode.className.indexOf('right') > -1) {
            if (popparentfloat == 'right') { // width < 1000
              pop.className = "popover left";
              pop.style.left = 'auto';
              pop.style.right = '7px';
            } else {
              pop.className = "popover right";
              pop.style.left = '0px';
              pop.style.right = 'auto';
            }
          } else {
            pop.className = "popover right";
            pop.style.left = '0px';
          }
        }
      }
      pop.style.top = top;
      pop.style.display = 'block';
    }
    

function test(name, address) { window.alert('Name is ' + name + '; address is ' + address); }  function mess() {  return('This is a test.'); } function opentest(url){ window.external.OpenPath();}